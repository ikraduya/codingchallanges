High-level
You’ve built a functional mini-grep with:

argument parsing (-r/-v/-i)
file/dir handling + recursion
matching modes (plain, \d, \w, ^, $-like helpers)
highlighting matched ranges
a KMP-based matcher for general substrings
Overall structure is reasonable, but there are a few correctness and maintainability risks.

Project/layout
Module/package naming: you’re importing ccgrep/comparison-utils and ccgrep/kmp. That implies your go.mod likely has module ccgrep. That’s fine locally, but consider using a real module path if you ever publish.
Folder names with hyphens are OK, but they’re atypical in Go. Most Go repos would use comparisonutils/ instead of comparison-utils/.
Correctness issues & panic risks
1) Indexing indexRanges[0] without guarding
In scanExpressionPattern, you do if indexRanges[0].Start > 0 { ... } under if isMatched, but you assume isMatched implies at least one range. That must hold for every CheckContainsOperation.
Right now, if any matcher returns (true, nil) or (true, emptySlice), you’ll panic.

Recommendation: enforce the contract or guard it:

2) Scanner split function looks incomplete
In processReader you override scanner.Split(...). In the snippet, the split function has branches but the “We have a full newline-terminated line” part is elided. If that code path is wrong, you can get:

empty tokens
infinite loops (advance=0, token=nil, err=nil repeatedly)
missing output (because Scan never returns tokens)
If you don’t need custom splitting, default ScanLines is usually sufficient (and easier to trust). If you need to preserve \n, do it carefully and add tests.

3) Case-insensitive matching and Unicode
You’re doing rune-wise matching with unicode.ToLower. That’s OK for basic case-folding, but it’s not full Unicode case-folding (e.g., Turkish dotted İ/ı edge cases). Probably acceptable for a toy grep, but worth noting.

API / design feedback
1) Too many responsibilities in ccgrep.go
ccgrep.go currently mixes:

CLI parsing
filesystem traversal
matching algorithms
formatting/highlighting
This makes it harder to test.

Recommendation: split into packages/files:

cmd/ccgrep/main.go (args + wiring)
internal/match/ (containsExpression, digit/word/begin/end)
internal/output/ (color + printing)
internal/fswalk/ (recurse, filter, file opening)
Even if you keep one module, splitting files by concern helps immediately.

2) Prefer flag (or cobra) over manual parsing
Your Args.Parse() manually inspects os.Args. That’s brittle and increases bug surface.
Go’s standard flag handles -i -v -r, usage, and errors consistently.

Performance & behavior
1) Repeated conversions string -> []rune
You correctly convert line and pattern to []rune for Unicode safety. However:

You also do []rune(strings.TrimSpace(string(s))) in containsEndingExpression which converts rune→string→rune, allocating twice.
Recommendation: avoid round-trips where possible. If you want to trim whitespace for runes, either trim the original string before converting, or implement rune-trim.

2) Highlighting prints many small fmt.Printf calls
Printing piecewise is fine for small files, but for performance it’s better to build into a strings.Builder and print once per line. Not required, but it’s a common improvement.

Style/idioms
Use shorter/idiomatic increment: i++ instead of i += 1 (Go convention).
if len(indexRanges) > 0 { return true, indexRanges } return false, nil can be simplified; also decide whether you want to return nil or []IndexRange{} consistently.
Avoid global vars unless needed. Your color funcs as globals are fine, but they can be grouped in a small type Theme struct or similar if you expand.
Testing recommendations
You have multiple matchers with subtle edge cases. Add unit tests for:

empty pattern
pattern longer than input
overlapping matches (KMP)
-i case-insensitive
\d ranges at start/end/middle
\w ranges around punctuation
beginning/ending expression matchers
If you want, tell me which functions you want covered first and I’ll generate *_test.go files for this workspace structure.

Questions to make the review more precise
What does kmp.ComputeLPSArray signature look like? (I see you pass runeComparisonFunc—good idea.)
Should matches be overlapping or non-overlapping in your grep output?
Should \w match underscore _ (common in regex) or only letters/digits (your current implementation)?